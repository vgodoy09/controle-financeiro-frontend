{"remainingRequest":"/home/victor.godoy/projeto-front-end-default/controle-financeiro-frontend/node_modules/thread-loader/dist/cjs.js!/home/victor.godoy/projeto-front-end-default/controle-financeiro-frontend/node_modules/babel-loader/lib/index.js!/home/victor.godoy/projeto-front-end-default/controle-financeiro-frontend/node_modules/eslint-loader/index.js??ref--13-0!/home/victor.godoy/projeto-front-end-default/controle-financeiro-frontend/src/_helpers/fake-backend.js","dependencies":[{"path":"/home/victor.godoy/projeto-front-end-default/controle-financeiro-frontend/src/_helpers/fake-backend.js","mtime":1543931740828},{"path":"/home/victor.godoy/projeto-front-end-default/controle-financeiro-frontend/.babelrc","mtime":1544005331407},{"path":"/home/victor.godoy/projeto-front-end-default/controle-financeiro-frontend/node_modules/cache-loader/dist/cjs.js","mtime":1543927896071},{"path":"/home/victor.godoy/projeto-front-end-default/controle-financeiro-frontend/node_modules/thread-loader/dist/cjs.js","mtime":1543927899826},{"path":"/home/victor.godoy/projeto-front-end-default/controle-financeiro-frontend/node_modules/babel-loader/lib/index.js","mtime":1530808242000},{"path":"/home/victor.godoy/projeto-front-end-default/controle-financeiro-frontend/node_modules/eslint-loader/index.js","mtime":1543927896984}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.configureFakeBackend = configureFakeBackend;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n// array in local storage for registered users\nvar users = JSON.parse(localStorage.getItem('users')) || [];\n\nfunction configureFakeBackend() {\n    var realFetch = window.fetch;\n    window.fetch = function (url, opts) {\n        return new Promise(function (resolve, reject) {\n            // wrap in timeout to simulate server api call\n            setTimeout(function () {\n\n                // authenticate\n                if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\n                    // get parameters from post request\n                    var params = JSON.parse(opts.body);\n\n                    // find if any user matches login credentials\n                    var filteredUsers = users.filter(function (user) {\n                        return user.username === params.username && user.password === params.password;\n                    });\n\n                    if (filteredUsers.length) {\n                        // if login details are valid return user details and fake jwt token\n                        var user = filteredUsers[0];\n                        var responseJson = {\n                            id: user.id,\n                            username: user.username,\n                            firstName: user.firstName,\n                            lastName: user.lastName,\n                            token: 'fake-jwt-token'\n                        };\n                        resolve({ ok: true, text: function text() {\n                                return Promise.resolve(JSON.stringify(responseJson));\n                            } });\n                    } else {\n                        // else return error\n                        reject('Username or password is incorrect');\n                    }\n\n                    return;\n                }\n\n                // get users\n                if (url.endsWith('/users') && opts.method === 'GET') {\n                    // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n                        resolve({ ok: true, text: function text() {\n                                return Promise.resolve(JSON.stringify(users));\n                            } });\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        reject('Unauthorised');\n                    }\n\n                    return;\n                }\n\n                // get user by id\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'GET') {\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n                        // find user by id in users array\n                        var urlParts = url.split('/');\n                        var id = parseInt(urlParts[urlParts.length - 1]);\n                        var matchedUsers = users.filter(function (user) {\n                            return user.id === id;\n                        });\n                        var _user = matchedUsers.length ? matchedUsers[0] : null;\n\n                        // respond 200 OK with user\n                        resolve({ ok: true, text: function text() {\n                                return JSON.stringify(_user);\n                            } });\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        reject('Unauthorised');\n                    }\n\n                    return;\n                }\n\n                // register user\n                if (url.endsWith('/users/register') && opts.method === 'POST') {\n                    // get new user object from post body\n                    var newUser = JSON.parse(opts.body);\n\n                    // validation\n                    var duplicateUser = users.filter(function (user) {\n                        return user.username === newUser.username;\n                    }).length;\n                    if (duplicateUser) {\n                        reject('Username \"' + newUser.username + '\" is already taken');\n                        return;\n                    }\n\n                    // save new user\n                    newUser.id = users.length ? Math.max.apply(Math, _toConsumableArray(users.map(function (user) {\n                        return user.id;\n                    }))) + 1 : 1;\n                    users.push(newUser);\n                    localStorage.setItem('users', JSON.stringify(users));\n\n                    // respond 200 OK\n                    resolve({ ok: true, text: function text() {\n                            return Promise.resolve();\n                        } });\n\n                    return;\n                }\n\n                // delete user\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'DELETE') {\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n                        // find user by id in users array\n                        var _urlParts = url.split('/');\n                        var _id = parseInt(_urlParts[_urlParts.length - 1]);\n                        for (var i = 0; i < users.length; i++) {\n                            var _user2 = users[i];\n                            if (_user2.id === _id) {\n                                // delete user\n                                users.splice(i, 1);\n                                localStorage.setItem('users', JSON.stringify(users));\n                                break;\n                            }\n                        }\n\n                        // respond 200 OK\n                        resolve({ ok: true, text: function text() {\n                                return Promise.resolve();\n                            } });\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        reject('Unauthorised');\n                    }\n\n                    return;\n                }\n\n                // pass through any requests not handled above\n                realFetch(url, opts).then(function (response) {\n                    return resolve(response);\n                });\n            }, 500);\n        });\n    };\n}",{"version":3,"sources":["src/_helpers/fake-backend.js"],"names":["configureFakeBackend","users","JSON","parse","localStorage","getItem","realFetch","window","fetch","url","opts","Promise","resolve","reject","setTimeout","endsWith","method","params","body","filteredUsers","filter","user","username","password","length","responseJson","id","firstName","lastName","token","ok","text","stringify","headers","Authorization","match","urlParts","split","parseInt","matchedUsers","newUser","duplicateUser","Math","max","map","push","setItem","i","splice","then","response"],"mappings":"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","file":"fake-backend.js","sourceRoot":"/home/victor.godoy/projeto-front-end-default/controle-financeiro-frontend","sourcesContent":["// array in local storage for registered users\nlet users = JSON.parse(localStorage.getItem('users')) || [];\n    \nexport function configureFakeBackend() {\n    let realFetch = window.fetch;\n    window.fetch = function (url, opts) {\n        return new Promise((resolve, reject) => {\n            // wrap in timeout to simulate server api call\n            setTimeout(() => {\n\n                // authenticate\n                if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\n                    // get parameters from post request\n                    let params = JSON.parse(opts.body);\n\n                    // find if any user matches login credentials\n                    let filteredUsers = users.filter(user => {\n                        return user.username === params.username && user.password === params.password;\n                    });\n\n                    if (filteredUsers.length) {\n                        // if login details are valid return user details and fake jwt token\n                        let user = filteredUsers[0];\n                        let responseJson = {\n                            id: user.id,\n                            username: user.username,\n                            firstName: user.firstName,\n                            lastName: user.lastName,\n                            token: 'fake-jwt-token'\n                        };\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(responseJson)) });\n                    } else {\n                        // else return error\n                        reject('Username or password is incorrect');\n                    }\n\n                    return;\n                }\n\n                // get users\n                if (url.endsWith('/users') && opts.method === 'GET') {\n                    // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(users))});\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        reject('Unauthorised');\n                    }\n\n                    return;\n                }\n\n                // get user by id\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'GET') {\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n                        // find user by id in users array\n                        let urlParts = url.split('/');\n                        let id = parseInt(urlParts[urlParts.length - 1]);\n                        let matchedUsers = users.filter(user => { return user.id === id; });\n                        let user = matchedUsers.length ? matchedUsers[0] : null;\n\n                        // respond 200 OK with user\n                        resolve({ ok: true, text: () => JSON.stringify(user)});\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        reject('Unauthorised');\n                    }\n\n                    return;\n                }\n\n                // register user\n                if (url.endsWith('/users/register') && opts.method === 'POST') {\n                    // get new user object from post body\n                    let newUser = JSON.parse(opts.body);\n\n                    // validation\n                    let duplicateUser = users.filter(user => { return user.username === newUser.username; }).length;\n                    if (duplicateUser) {\n                        reject('Username \"' + newUser.username + '\" is already taken');\n                        return;\n                    }\n\n                    // save new user\n                    newUser.id = users.length ? Math.max(...users.map(user => user.id)) + 1 : 1;\n                    users.push(newUser);\n                    localStorage.setItem('users', JSON.stringify(users));\n\n                    // respond 200 OK\n                    resolve({ ok: true, text: () => Promise.resolve() });\n\n                    return;\n                }\n\n                // delete user\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'DELETE') {\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n                        // find user by id in users array\n                        let urlParts = url.split('/');\n                        let id = parseInt(urlParts[urlParts.length - 1]);\n                        for (let i = 0; i < users.length; i++) {\n                            let user = users[i];\n                            if (user.id === id) {\n                                // delete user\n                                users.splice(i, 1);\n                                localStorage.setItem('users', JSON.stringify(users));\n                                break;\n                            }\n                        }\n\n                        // respond 200 OK\n                        resolve({ ok: true, text: () => Promise.resolve() });\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        reject('Unauthorised');\n                    }\n\n                    return;\n                }\n\n                // pass through any requests not handled above\n                realFetch(url, opts).then(response => resolve(response));\n\n            }, 500);\n        });\n    }\n}"]}]}